# 选一把好锤子——浅谈几种科学计算候选语言的优劣

> If all you have is a hammer, everything looks like a nail.
>
> —— Law of the instrument, by  Abraham Maslow 


“XX只是工具，YY才是重点/核心/本质/精髓”，在谈论工具时，我们经常能听到这样的论调。然而，从另一个方面来说，工具影响了（如果说还未达到决定的程度的话）我们认知世界、改造世界的方法/角度/效率，以及结果。假设我们是在用算筹，而不是Matlab来计算一个特殊函数的定积分，那么我们绝无底气说出“Matlab只是一种工具，数学才是本质”这样举重若轻的话。



所以，一定要选好一把锤子。

以及，一定要选一把好锤子。



作为一个科学工作者，作者需要时常写一些小程序来求解不同的科学计算问题，比如数值优化、参数估计、数据采集之后的在线数据处理等等，不同的问题当然需要选用不同的编程语言来实现处理算法。这里我并不想给出一个诸如如何选型的指导，毕竟世界是复杂的。**我只想发一点由编程语言的选择所引出的牢骚。**


## Python

就从你开始了，Python。

> Life is short 
>
> (You need Python)”
>
> -- Bruce Eckel
> 
> ANSI C++ Comitee member

Python是当下“做数据分析的人”的人挂在嘴边最多的一种语言。所谓“人生苦短，你需要Python”是Python的一句广告词，暗示了它似乎能节约用户的时间。然而，当30秒过去了，你的程序的输出只往上滚动了一行，而你又知道，你写的程序要输出一万行调试信息才结束的时候，你一定觉得自己被骗了！



确实，执行速度从来不是Python的卖点，编写速度才是。然而，当你的程序千辛万苦完成了99%的任务，花了三天，正当你准备检阅一下你漂亮的成果的时候，屏幕上跳出了

> AttributeError: XX object has no attribute 'YY'

你欲哭无泪。是的，Python是一种动态类型语言，一个变量的类型只有等到它实际获得了它所指向的内容的时候，才能确定。这也就导致了很多错误只有等到它瞒不下去的时候才会爆发。

以上黑了Python两点：太慢以及没有静态检查。

当然，Python的优点也是无法磨灭的。首先，它很容易写**出来**;其次，它有很多很好用的库比如numpy, scipy, matplotlib, etc。这两个优点使得Python在一种情况下成为求解科学计算问题的首选：顺手写出，一次使用，写出来花半小时，运行半小时之内的程序用Python是很适合的。如果运行时间超过24小时，我建议就别选Python了，毕竟你不知道它是否会在第23小时的59分跳出一个错误导致程序退出，而内存中尚未存盘的结果随着操作系统的任务调度被其它程序覆盖掉，从而浪费掉你苦短的人生中的一天。


## Julia

如果说有什么语言能与Python有瑜亮之争的话，我首先想到的是Julia。Julia恰恰修补了或者说至少部分修补了Python的命门——由于动态类型系统所导致的低效和易错性。我做过一个benchmark，通过自适应梯形积分算法来比较不同的语言的运行效率。


[Benchmark](https://github.com/astrojhgu/adaptrapezoid_benchmark)


**在这一测试中Julia的运行效率非常接近C语言！**根本原因是在Julia中，用户可以引入必要的类型信息，让Julia能作出充分的优化。这一优化的效果是显著的，对我来说，说它是黑科技也不为过。与此同时，作为一种脚本语言，它已经被很自然地整合到Jupyter notebook里了，所以用户界面非常友好。

即使是在Python早已抢占了“数据分析”这个行业的先机的当下，我依然相信Julia能获得更好的发展。

Julia的主要问题，我认为有1.5点：首先，它作为一种新兴的专注于科学计算的语言，它的库仍然不够多（较之Python）。剩下那半点是我个人的口味决定的：它的数组指标居然是从1开始的——异端！这当然是有原因的——很显然，Julia的作者们大都有Matlab、R、Fortran背景，这几种语言在数值计算领域都占有一席之地。

目前，我个人不再推荐Python作为**一次性**科学计算编程的语言，转而推荐Julia。

## C/C++

如果你想要极致的效率，你准备榨干CPU的每一滴油水，这还不够，你甚至连GPU也要一起榨，而且你自认为你写的科学计算程序有一天会被广泛使用在不同的地方，或者一个问题，必须在0.9秒里算出来，1.1秒算出来就毫无意义（比如高速实时在线数据处理，特别是高速数据采集），那么你无疑需要考虑使用C/C++。

尽管C和C++总是被连在一起写出来，但是它们其实是两种语言。不，它们其实是1+N种语言，这里的N属于C++——它包含了structured, C with class, Object-based, Object-Oriented, Functional, template meta programming等好几种风格迥异的写法，以至于它们相互之间长得一点儿都不像。

相对而言，用C/C++写数值程序其实是很痛苦的， debug起来更痛苦。除非万不得已，其实我并不是很推荐C/C++。尽管十多年来C++一直是我的科学计算主力语言，见证了它从C++98, 03, 11, 14一路演进到C++17，自从稍微瞄了一眼C++20标准草案之后，我只能号称我曾经会过C++了。

## Haskell、Idris

如果说有什么语言能体现出优雅的内在一致性和数学的美感的话，我脑海中会浮现出两种语言——Haskell和Idris。Haskell语言的特点是纯粹，它没有循环（可以通过递归来实现循环），变量一经赋值即不可更改，整个程序就是一个大的表达式求值。强大的类型系统——静态类型检查和类型推导让程序的错误尽可能地在运行之前就暴露出来，编译器忠实地为你的程序保驾护航。

Idris可以说是Haskell的加强版本，在Haskell的基础之上添加了更多的功能，稍微复杂了那么一点，同时也更为强大。

但是Haskell和Idris的思想和现实世界的CPU并不十分相容——CPU一点都不纯粹（哪有寄存器内容不能修改的CPU），以至于Haskell代码翻译为native code（i.e., 机器码）之后的执行效率相当不高。一个以直观思路写出来的Haskell程序很难达到令人满意的运行效率。这是我尽管很喜欢这两种语言，但不得不忍痛割爱，不在工作中使用它们来求解问题的原因。

## 什么？你说怎么还没轮到Fortran？

Fortran连个动态内存分配都写不顺，还没有自动扩增数组(类似于C++的std::vector)，反正我写不来。



## Mathematica和Maple?

至于Mathematica和Maple，这两个主要是用来搞符号计算的，所以这里没有考虑。


# 最后是私货时间

Last but not least —— Rust语言

如果说，有什么语言能干掉C/C++的话，那一定就是Rust了。Rust给我个人最的直观感受是——只要编译通过了，调试的时候通常不会有大的错误。即使没有认真看书，编译器也能把你教得服服贴贴的。看上去写出来的程序很难编译通过是一个缺点，但从另一个（正确的）角度来说，尽早暴露可能的错误和缺陷绝对是一个巨大的优点。

更重要的是——它还高效。Rust是一种可以很自然地操作原始内存，尽量避免不必要的开销的底层语言，这令它可以很容易达到和C语言相同的速度。与此同时，诸多计算机科学的现代成果被应用到这个语言的设计之中，使得它也具有一些高层次的语法特征，例如匿名函数、泛型、类型推断、类型约束等等。这些语法特征使得以Rust语言写成的库很难被误用。例如，库的设计者不必仅仅依赖文档来告诉使用者，某一片内存是应该由调用者释放还是被调用者释放。同时，类型约束语法作为一种现代化的语法特征，使得Rust的泛型代码不会像C++的模板语法那样，一旦出错就甩给用户几页甚至十几页的错误信息。

现代化包管理设施令Rust不必像C/C++那样从零碎开始写Makefile来组织一个软件工程的构建过程。只需一条命令就能生成一个Rust语言工程的基本目录结构，只需要往工程的声明文件里添加一行声明，就能将它所依赖的外部库从软件仓库pull下来。

如果说Rust有什么令我不满意的地方的话，我希望它有朝一日能像C++那样使用非类型模板参数。



## 结语

本文从Python开始，以Rust结尾，阐述了我在日常科学计算中所选用语言的一些浅见。可能有人会问，你罗里吧嗦说了一大通，没个结论吗？我只能说，就我个人偏好而言，一次性编程用Julia，需要反复打磨的程序推荐Rust，如果需要用到极致的性能，需要对内存精确控制，只有C/C++可选。

以上就是我关于科学计算编程语言选择的一些牢骚，希望能给读者提供一些参考。
